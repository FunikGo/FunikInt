<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Advanced Procedural Planet Generator v2.0 - FIXED</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        
        .control-panel {
            position: fixed; top: 20px; left: 20px; background: rgba(10, 15, 25, 0.95); 
            border: 1px solid rgba(100, 180, 255, 0.4); border-radius: 16px; padding: 24px; 
            color: #e0e8f0; min-width: 340px; max-width: 380px; max-height: 85vh; overflow-y: auto;
            backdrop-filter: blur(20px); box-shadow: 0 12px 40px rgba(0,0,0,0.6);
        }
        .panel-title { 
            font-size: 22px; font-weight: 800; margin-bottom: 24px; color: #70c0ff; 
            text-transform: uppercase; letter-spacing: 3px; border-bottom: 2px solid rgba(100,180,255,0.5); 
            padding-bottom: 12px; text-align: center;
        }
        .tab-buttons { display: flex; gap: 6px; margin-bottom: 20px; }
        .tab-btn { flex: 1; padding: 12px 8px; background: rgba(40,60,80,0.8); color: #90a8c0; 
            border: 1px solid rgba(100,180,255,0.3); border-radius: 10px; font-weight: 600; 
            cursor: pointer; transition: all 0.3s; font-size: 13px; }
        .tab-btn.active { background: linear-gradient(135deg, #2080ff, #1060d0); color: #fff; 
            border-color: #50a0ff; transform: scale(1.02); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        .control-group { margin-bottom: 22px; }
        .control-label { display: block; font-size: 13px; color: #90a8c0; margin-bottom: 8px; 
            text-transform: uppercase; letter-spacing: 1px; font-weight: 500; }
        .control-value { float: right; color: #70c0ff; font-weight: 700; }
        input[type="range"] { width: 100%; height: 8px; border-radius: 4px; 
            background: linear-gradient(90deg, #1a2535, #2a3a50); outline: none; cursor: pointer; 
            appearance: none; transition: background 0.2s; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 20px; height: 20px; 
            border-radius: 50%; background: linear-gradient(135deg, #50a0ff, #3080e0); cursor: pointer; 
            box-shadow: 0 4px 12px rgba(80,160,255,0.6); transition: all 0.2s; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.3); box-shadow: 0 6px 16px rgba(80,160,255,0.8); }
        .btn { width: 100%; padding: 14px 20px; border: none; border-radius: 12px; font-size: 14px; 
            font-weight: 700; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; 
            transition: all 0.4s; margin-bottom: 12px; position: relative; overflow: hidden; }
        .btn::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; 
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent); transition: left 0.5s; }
        .btn:hover::before { left: 100%; }
        .btn-primary { background: linear-gradient(135deg, #2080ff, #1060d0); color: #fff; 
            box-shadow: 0 6px 20px rgba(32,128,255,0.5); }
        .btn-primary:hover { transform: translateY(-3px); box-shadow: 0 12px 30px rgba(32,128,255,0.7); }
        .btn-secondary { background: rgba(60,80,100,0.8); color: #c0d0e0; border: 1px solid rgba(100,180,255,0.4); }
        .btn-preset { background: rgba(60,80,100,0.8); color: #c0d0e0; border: 1px solid rgba(100,180,255,0.3); 
            font-size: 12px; padding: 12px 10px; margin: 2px; width: auto; }
        .btn-preset:hover { background: rgba(100,180,255,0.4); color: #fff; transform: scale(1.05); }
        .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }
        .btn-mode { flex: 1; min-width: 75px; padding: 12px 10px; font-size: 12px; 
            background: rgba(40,60,80,0.8); color: #90a8c0; border: 1px solid rgba(100,180,255,0.3); }
        .btn-mode.active { background: linear-gradient(135deg, #2080ff, #1060d0); color: #fff; border-color: #50a0ff; }
        .toggle-group { display: flex; align-items: center; justify-content: space-between; }
        .toggle { position: relative; width: 60px; height: 30px; background: #1a2535; border-radius: 15px; 
            cursor: pointer; transition: all 0.3s; border: 1px solid rgba(100,180,255,0.3); }
        .toggle.active { background: linear-gradient(135deg, #2080ff, #1060d0); }
        .toggle::after { content: ''; position: absolute; top: 3px; left: 3px; width: 24px; height: 24px; 
            background: #e0e8f0; border-radius: 50%; transition: transform 0.3s; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        .toggle.active::after { transform: translateX(30px); }
        .stats { margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(100,180,255,0.3); 
            font-size: 12px; color: #607080; line-height: 1.6; }
        .legend { margin-top: 16px; padding: 16px; background: rgba(20,30,45,0.9); border-radius: 12px; 
            border: 1px solid rgba(100,180,255,0.2); }
        .legend-title { font-size: 13px; color: #70c0ff; margin-bottom: 12px; text-transform: uppercase; font-weight: 600; }
        .legend-gradient { height: 16px; border-radius: 8px; margin-bottom: 8px; box-shadow: inset 0 2px 4px rgba(0,0,0,0.3); }
        .legend-labels { display: flex; justify-content: space-between; font-size: 11px; color: #607080; font-weight: 500; }
        #fps-display { position: fixed; top: 10px; right: 20px; color: #70c0ff; font-size: 16px; font-weight: 700; 
            text-shadow: 0 0 10px rgba(112,192,255,0.5); }
        #audio-toggle, #fullscreen-toggle { position: fixed; bottom: 20px; right: 20px; width: 60px; height: 60px; 
            border-radius: 50%; background: rgba(10,15,25,0.95); border: 2px solid #70c0ff; cursor: pointer; 
            margin: 10px; transition: all 0.3s; font-size: 20px; color: #70c0ff; }
        #fullscreen-toggle { right: 90px; }
        #export-menu { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10,15,25,0.98); 
            border: 2px solid #70c0ff; border-radius: 20px; padding: 30px; color: #e0e8f0; display: none; 
            text-align: center; min-width: 300px; z-index: 1000; }
        @media (max-width: 768px) { .control-panel { left: 10px; right: 10px; min-width: auto; max-width: none; } }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div class="control-panel">
        <div class="panel-title">üöÄ Advanced Planet Generator v2.0</div>
        <div class="tab-buttons">
            <button class="tab-btn active" data-tab="terrain">üåç Terrain</button>
            <button class="tab-btn" data-tab="atmosphere">‚òÅÔ∏è Atmosphere</button>
            <button class="tab-btn" data-tab="effects">‚ú® Effects</button>
        </div>
        
        <!-- Terrain Tab -->
        <div id="terrain-tab" class="tab-content active">
            <div class="control-group">
                <button class="btn btn-primary" id="regenerate">üåü Generate New Planet</button>
            </div>
            <div class="control-group">
                <label class="control-label">Roughness <span class="control-value" id="roughness-value">0.50</span></label>
                <input type="range" id="roughness" min="0.1" max="1.5" step="0.05" value="0.5">
            </div>
            <div class="control-group">
                <label class="control-label">Sea Level <span class="control-value" id="sealevel-value">0.40</span></label>
                <input type="range" id="sealevel" min="0" max="1" step="0.02" value="0.4">
            </div>
            <div class="control-group">
                <label class="control-label">Rotation Speed <span class="control-value" id="rotation-value">0.20</span></label>
                <input type="range" id="rotation" min="0" max="2" step="0.05" value="0.2">
            </div>
            <div class="control-group">
                <label class="control-label">Shading Mode</label>
                <div class="btn-group">
                    <button class="btn-mode active" data-mode="height">Height</button>
                    <button class="btn-mode" data-mode="temperature">Temp</button>
                    <button class="btn-mode" data-mode="humidity">Humid</button>
                    <button class="btn-mode" data-mode="volcano">Lava</button>
                </div>
            </div>
            <div class="control-group">
                <div class="legend" id="legend-container">
                    <div class="legend-title">Elevation</div>
                    <div class="legend-gradient" id="legend-gradient"></div>
                    <div class="legend-labels" id="legend-labels">
                        <span>Deep Ocean</span><span>Volcano Peaks</span>
                    </div>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Presets</label>
                <div class="btn-group">
                    <button class="btn-preset" id="preset-earth">üåç Earth</button>
                    <button class="btn-preset" id="preset-mars">üî¥ Mars</button>
                    <button class="btn-preset" id="preset-gas">ü™ê Gas Giant</button>
                </div>
            </div>
        </div>

        <!-- Atmosphere Tab -->
        <div id="atmosphere-tab" class="tab-content">
            <div class="control-group">
                <div class="toggle-group">
                    <label class="control-label" style="margin-bottom: 0;">Day-Night Cycle</label>
                    <div class="toggle active" id="daynight-toggle"></div>
                </div>
            </div>
            <div class="control-group">
                <div class="toggle-group">
                    <label class="control-label" style="margin-bottom: 0;">Atmosphere</label>
                    <div class="toggle active" id="atmosphere-toggle"></div>
                </div>
            </div>
            <div class="control-group">
                <div class="toggle-group">
                    <label class="control-label" style="margin-bottom: 0;">Planet Rings</label>
                    <div class="toggle" id="rings-toggle"></div>
                </div>
            </div>
            <div class="control-group">
                <label class="control-label">Cloud Density <span class="control-value" id="cloud-density-value">0.60</span></label>
                <input type="range" id="cloud-density" min="0" max="1" step="0.05" value="0.6">
            </div>
        </div>

        <!-- Effects Tab -->
        <div id="effects-tab" class="tab-content">
            <div class="control-group">
                <label class="control-label">Bloom Intensity <span class="control-value" id="bloom-value">0.70</span></label>
                <input type="range" id="bloom" min="0" max="2" step="0.1" value="0.7">
            </div>
            <div class="control-group">
                <button class="btn btn-secondary" id="fullscreen-btn">‚õ∂ Fullscreen</button>
                <button class="btn btn-secondary" id="screenshot-btn">üì∏ Screenshot</button>
            </div>
        </div>

        <div class="stats">
            <div>üå± Seed: <span id="seed-display">-</span></div>
            <div>üìä Vertices: <span id="vertex-count">-</span></div>
            <div>‚ö° FPS: <span id="fps-display">-</span></div>
        </div>
    </div>

    <button id="audio-toggle" title="Toggle Ambient Music">üéµ</button>
    <button id="fullscreen-toggle" title="Fullscreen">‚õ∂</button>
    
    <div id="export-menu">
        <h3>üì§ Export Options</h3>
        <button class="btn btn-primary" id="export-screenshot">High-Res Screenshot</button>
        <button class="btn btn-primary" id="export-json">Save Parameters</button>
        <button class="btn btn-secondary" id="export-close">Close</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ‚úÖ FIXED: Custom Seeded Random Number Generator
        class SeededRandom {
            constructor(seed) {
                this.seed = seed >>> 0;
            }
            next() {
                this.seed = (this.seed * 16807) % 2147483647;
                return (this.seed - 1) / 2147483646;
            }
            random() {
                return this.next();
            }
        }

        // ‚úÖ FIXED: Simplex Noise dengan Seeded Random
        class SimplexNoise {
            constructor(seed) {
                this.random = new SeededRandom(seed);
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(this.random.random() * (i + 1));
                    [this.p[i], this.p[j]] = [this.p[j], this.p[i]];
                }
                this.perm = new Uint8Array(512);
                this.permMod12 = new Uint8Array(512);
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
            }

            dot(g, x, y, z) {
                return g[0] * x + g[1] * y + g[2] * z;
            }

            noise3D(x, y, z) {
                const F3 = 1/3, G3 = 1/6;
                const grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],
                              [1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
                
                let n0, n1, n2, n3;
                const s = (x + y + z) * F3;
                const i = Math.floor(x + s), j = Math.floor(y + s), k = Math.floor(z + s);
                const t = (i + j + k) * G3;
                const X0 = i - t, Y0 = j - t, Z0 = k - t;
                const x0 = x - X0, y0 = y - Y0, z0 = z - Z0;
                
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }

                const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2*G3, y2 = y0 - j2 + 2*G3, z2 = z0 - k2 + 2*G3;
                const x3 = x0 - 1 + 3*G3, y3 = y0 - 1 + 3*G3, z3 = z0 - 1 + 3*G3;

                const ii = i & 255, jj = j & 255, kk = k & 255;
                const t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
                n0 = t0 < 0 ? 0 : t0*t0*t0*t0 * this.dot(grad3[this.permMod12[ii + this.perm[jj + this.perm[kk]]]], x0, y0, z0);
                const t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
                n1 = t1 < 0 ? 0 : t1*t1*t1*t1 * this.dot(grad3[this.permMod12[ii+i1 + this.perm[jj+j1 + this.perm[kk+k1]]]], x1, y1, z1);
                const t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
                n2 = t2 < 0 ? 0 : t2*t2*t2*t2 * this.dot(grad3[this.permMod12[ii+i2 + this.perm[jj+j2 + this.perm[kk+k2]]]], x2, y2, z2);
                const t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
                n3 = t3 < 0 ? 0 : t3*t3*t3*t3 * this.dot(grad3[this.permMod12[ii+1 + this.perm[jj+1 + this.perm[kk+1]]]], x3, y3, z3);
                
                return 32 * (n0 + n1 + n2 + n3);
            }

            fbm(x, y, z, octaves = 6, lacunarity = 2, persistence = 0.5) {
                let value = 0, amplitude = 1, frequency = 1, maxValue = 0;
                for (let i = 0; i < octaves; i++) {
                    value += amplitude * this.noise3D(x * frequency, y * frequency, z * frequency);
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }
                return value / maxValue;
            }
        }

        // Scene variables
        let scene, camera, renderer, controls, composer;
        let planet, atmosphere, clouds, rings, starfield, sunLight;
        let simplex, currentSeed = Math.random() * 10000;
        let originalPositions = null;
        let params = {
            roughness: 0.5, seaLevel: 0.4, rotationSpeed: 0.2, shadingMode: 'height',
            dayNightEnabled: true, atmosphereEnabled: true, cloudDensity: 0.6,
            ringsEnabled: false, bloomIntensity: 0.7, time: 0
        };

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 4);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post-processing
            composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85
            );
            bloomPass.threshold = 0; bloomPass.strength = params.bloomIntensity; bloomPass.radius = 0;
            composer.addPass(bloomPass);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; controls.dampingFactor = 0.05;
            controls.minDistance = 2; controls.maxDistance = 10;

            createStarfield();
            createLighting();
            generatePlanet();
            setupEventListeners();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function createStarfield() {
            const starsGeometry = new THREE.BufferGeometry();
            const starCount = 5000;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            const sizes = new Float32Array(starCount);

            for (let i = 0; i < starCount; i++) {
                const i3 = i * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 50 + Math.random() * 50;
                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);

                const colorTemp = Math.random();
                if (colorTemp > 0.9) { colors[i3] = 1; colors[i3 + 1] = 0.8; colors[i3 + 2] = 1; }
                else if (colorTemp > 0.7) { colors[i3] = 1; colors[i3 + 1] = 0.9; colors[i3 + 2] = 0.8; }
                else { colors[i3] = 1; colors[i3 + 1] = 0.9; colors[i3 + 2] = 0.6; }
                sizes[i] = 0.5 + Math.random() * 1.5;
            }

            starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            starsGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const starsMaterial = new THREE.ShaderMaterial({
                uniforms: { uTime: { value: 0 } },
                vertexShader: `
                    attribute float size;
                    varying vec3 vColor;
                    uniform float uTime;
                    void main() {
                                            vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        float twinkle = sin(uTime * 2.0 + position.x * 10.0) * 0.3 + 0.7;
                        gl_PointSize = size * twinkle * 300.0 / -mvPosition.z;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.0, 0.5, dist);
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            starfield = new THREE.Points(starsGeometry, starsMaterial);
            starfield.name = 'starfield';
            scene.add(starfield);
        }

        function createLighting() {
            sunLight = new THREE.DirectionalLight(0xfff0e0, 2);
            sunLight.position.set(5, 3, 5);
            scene.add(sunLight);
            scene.add(new THREE.AmbientLight(0x1a2040, 0.3));
        }

        function generatePlanet() {
            // Cleanup existing objects
            if (planet) {
                scene.remove(planet);
                planet.geometry.dispose();
                planet.material.dispose();
            }
            if (atmosphere) {
                scene.remove(atmosphere);
                atmosphere.geometry.dispose();
                atmosphere.material.dispose();
            }
            if (clouds) {
                scene.remove(clouds);
                clouds.geometry.dispose();
                clouds.material.dispose();
            }
            if (rings) {
                scene.remove(rings);
                rings.geometry.dispose();
                rings.material.dispose();
            }

            simplex = new SimplexNoise(currentSeed);
            document.getElementById('seed-display').textContent = Math.floor(currentSeed);

            // Create high-detail icosahedron
            const geometry = new THREE.IcosahedronGeometry(1, 48);
            document.getElementById('vertex-count').textContent = geometry.attributes.position.count.toLocaleString();
            
            originalPositions = new Float32Array(geometry.attributes.position.array);
            applyTerrain(geometry);
            
            const material = createPlanetMaterial();
            planet = new THREE.Mesh(geometry, material);
            scene.add(planet);

            createAtmosphere();
            createClouds();
            createRings();
        }

        function applyTerrain(geometry) {
            const positions = geometry.attributes.position.array;
            const elevations = new Float32Array(positions.length);
            const colors = new Float32Array(positions.length);

            for (let i = 0; i < positions.length; i += 3) {
                const ox = originalPositions[i], oy = originalPositions[i + 1], oz = originalPositions[i + 2];
                const len = Math.sqrt(ox * ox + oy * oy + oz * oz);
                const nx = ox / len, ny = oy / len, nz = oz / len;

                // Multi-octave terrain generation
                let elevation = 0;
                elevation += simplex.fbm(nx * 2, ny * 2, nz * 2, 6, 2, 0.5) * params.roughness;
                elevation += simplex.fbm(nx * 4.1, ny * 4, nz * 4, 4, 2, 0.5) * params.roughness * 0.3;
                
                // Ridged noise for sharp mountains/volcanoes
                let ridged = 1 - Math.abs(simplex.fbm(nx * 3, ny * 3, nz * 3, 4, 2, 0.5));
                ridged *= ridged;
                elevation += ridged * params.roughness * 0.4;

                elevation = Math.max(-0.5, Math.min(0.5, elevation));
                const newLen = 1 + elevation * 0.15;
                positions[i] = nx * newLen;
                positions[i + 1] = ny * newLen;
                positions[i + 2] = nz * newLen;

                elevations[i] = elevation;
                colors[i] = elevation;           // Height data
                colors[i + 1] = Math.abs(ny);    // Latitude
                colors[i + 2] = simplex.fbm(nx * 3.2, ny * 3, nz * 3, 3, 2, 0.5); // Humidity
            }

            geometry.setAttribute('aElevation', new THREE.BufferAttribute(elevations, 3));
            geometry.setAttribute('aColorData', new THREE.BufferAttribute(colors, 3));
            geometry.computeVertexNormals();
        }

        function createPlanetMaterial() {
            return new THREE.ShaderMaterial({
                uniforms: {
                    uSunPosition: { value: new THREE.Vector3(5, 3, 5) },
                    uSeaLevel: { value: params.seaLevel },
                    uShadingMode: { value: 0 },
                    uTime: { value: 0 }
                },
                vertexShader: `
                    attribute vec3 aElevation;
                    attribute vec3 aColorData;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    varying vec3 vWorldPosition;
                    varying vec3 vElevation;
                    varying vec3 vColorData;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        vElevation = aElevation;
                        vColorData = aColorData;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uSunPosition;
                    uniform float uSeaLevel;
                    uniform int uShadingMode;
                    uniform float uTime;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    varying vec3 vElevation;
                    varying vec3 vColorData;

                    vec3 heightColor(float e) {
                        float sea = uSeaLevel - 0.5;
                        if (e < sea - 0.1) return mix(vec3(0.02, 0.05, 0.15), vec3(0.05, 0.15, 0.35), (e - (sea - 0.1)) * 5.0);
                        else if (e < sea) return mix(vec3(0.05, 0.15, 0.35), vec3(0.1, 0.35, 0.5), (e - sea) * 10.0);
                        else if (e < sea + 0.05) return mix(vec3(0.76, 0.7, 0.5), vec3(0.5, 0.6, 0.3), (e - (sea + 0.05)));
                        else if (e < sea + 0.2) return mix(vec3(0.5, 0.6, 0.3), vec3(0.2, 0.45, 0.2), (e - (sea + 0.05)) * 0.66);
                        else if (e < sea + 0.35) return mix(vec3(0.2, 0.45, 0.2), vec3(0.15, 0.35, 0.15), (e - (sea + 0.2)) * 0.66);
                        else if (e < sea + 0.45) return mix(vec3(0.15, 0.35, 0.15), vec3(0.4, 0.35, 0.3), (e - (sea + 0.35)) * 10.0);
                        else return mix(vec3(0.4, 0.35, 0.3), vec3(0.95, 0.95, 1.0), clamp((e - (sea + 0.45)) * 10.0, 0.0, 1.0));
                    }

                    vec3 volcanoColor(float e, float humidity) {
                        if (e > 0.4) {
                            float glow = sin(uTime * 3.0) * 0.5 + 0.5;
                            return mix(vec3(0.95, 0.95, 1.0), vec3(1.0, 0.3, 0.1) + glow * vec3(0.5, 0.2, 0.0), humidity);
                        }
                        return heightColor(e);
                    }

                    vec3 temperatureColor(float latitude, float elevation) {
                        float baseTemp = 1.0 - latitude * 2.0;
                        float temp = clamp(baseTemp - elevation * 0.8, 0.0, 1.0);
                        if (temp < 0.25) return mix(vec3(0.9, 0.95, 1.0), vec3(0.3, 0.5, 0.8), temp * 4.0);
                        else if (temp < 0.5) return mix(vec3(0.3, 0.5, 0.8), vec3(0.3, 0.7, 0.4), (temp - 0.25) * 4.0);
                        else if (temp < 0.75) return mix(vec3(0.3, 0.7, 0.4), vec3(0.9, 0.85, 0.3), (temp - 0.5) * 4.0);
                        else return mix(vec3(0.9, 0.85, 0.3), vec3(0.9, 0.3, 0.2), (temp - 0.75) * 4.0);
                    }

                    void main() {
                        float elevation = vElevation.x;
                        float latitude = vColorData.y;
                        float humidity = vColorData.z;
                        
                        vec3 baseColor;
                        if (uShadingMode == 0) baseColor = heightColor(elevation);
                        else if (uShadingMode == 1) baseColor = temperatureColor(latitude, elevation);
                        else if (uShadingMode == 2) baseColor = mix(vec3(0.85, 0.75, 0.55), vec3(0.15, 0.4, 0.2), humidity);
                        else baseColor = volcanoColor(elevation, humidity);

                        vec3 lightDir = normalize(uSunPosition);
                        float NdotL = max(dot(vNormal, lightDir), 0.0);
                        vec3 ambient = vec3(0.08, 0.1, 0.15);
                        
                        vec3 nightGlow = vec3(0.0);
                        if (NdotL < 0.0) {
                            float nightIntensity = pow(max(-NdotL, 0.0), 2.0) * 0.15;
                            nightGlow = vec3(1.0, 0.9, 0.6) * nightIntensity;
                        }
                        
                        float terminator = smoothstep(-0.1, 0.2, NdotL);
                        vec3 finalColor = baseColor * (ambient + NdotL * 0.9) + nightGlow;

                        float sea = uSeaLevel - 0.5;
                        if (elevation < sea + 0.02) {
                            vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                            vec3 halfDir = normalize(lightDir + viewDir);
                            float spec = pow(max(dot(vNormal, halfDir), 0.0), 64.0);
                            finalColor += vec3(1.0, 0.95, 0.9) * spec * 0.5 * terminator;
                        }

                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `
            });
        }

        function createAtmosphere() {
            const geometry = new THREE.IcosahedronGeometry(1.12, 32);
            const material = new THREE.ShaderMaterial({
                uniforms: { uSunPosition: { value: new THREE.Vector3(5, 3, 5) } },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uSunPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    void main() {
                        vec3 viewDir = normalize(cameraPosition - vWorldPosition);
                        vec3 lightDir = normalize(uSunPosition);
                        float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0);
                        float NdotL = dot(vNormal, lightDir);
                        float lightInfluence = smoothstep(-0.5, 0.5, NdotL);
                        
                        vec3 dayColor = vec3(0.3, 0.6, 1.0);
                        vec3 sunsetColor = vec3(1.0, 0.5, 0.2);
                        vec3 nightColor = vec3(0.05, 0.1, 0.2);
                        float sunsetFactor = smoothstep(-0.3, 0.1, NdotL) * smoothstep(0.5, 0.1, NdotL);
                        
                        vec3 atmosphereColor = mix(nightColor, dayColor, lightInfluence);
                        atmosphereColor = mix(atmosphereColor, sunsetColor, sunsetFactor * 0.5);
                        
                        float alpha = fresnel * 0.6 * lightInfluence * 0.7 + 0.3;
                        gl_FragColor = vec4(atmosphereColor, alpha);
                    }
                `,
                transparent: true,
                side: THREE.BackSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            atmosphere = new THREE.Mesh(geometry, material);
            atmosphere.visible = params.atmosphereEnabled;
            scene.add(atmosphere);
        }

        function createClouds() {
            const geometry = new THREE.IcosahedronGeometry(1.03, 32);
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uCloudDensity: { value: params.cloudDensity },
                    uTime: { value: 0 }
                },
                vertexShader: `
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    uniform float uTime;
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vec3 pos = position;
                        pos.x += sin(uTime * 0.1 + position.y * 5.0) * 0.02;
                        pos.z += cos(uTime * 0.1 + position.x * 5.0) * 0.02;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float uCloudDensity;
                    uniform float uTime;
                    varying vec2 vUv;
                    varying vec3 vNormal;
                    void main() {
                        float density = uCloudDensity;
                        float noise = sin(vUv.x * 10.0 + uTime) * sin(vUv.y * 10.0 + uTime * 0.7) * 0.5 + 0.5;
                        density *= noise * 2.0;
                        vec3 cloudColor = vec3(1.0, 1.0, 0.9);
                        float alpha = clamp(density, 0.0, 1.0);
                        gl_FragColor = vec4(cloudColor, alpha * 0.8);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });
            clouds = new THREE.Mesh(geometry, material);
            scene.add(clouds);
        }

        function createRings() {
            const ringGeometry = new THREE.RingGeometry(1.5, 3.5, 64, 1);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x88aaff, 
                transparent: true, 
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            rings = new THREE.Mesh(ringGeometry, ringMaterial);
            rings.rotation.x = -Math.PI * 0.5;
            rings.visible = false;
            scene.add(rings);
        }

        function setupEventListeners() {
            // Tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(`${btn.dataset.tab}-tab`).classList.add('active');
                });
            });

            // Controls
            document.getElementById('regenerate').addEventListener('click', () => {
                currentSeed = Math.random() * 10000;
                generatePlanet();
            });

            document.getElementById('roughness').addEventListener('input', (e) => {
                params.roughness = parseFloat(e.target.value);
                document.getElementById('roughness-value').textContent = params.roughness.toFixed(2);
                if (planet) updateTerrain();
            });

            document.getElementById('sealevel').addEventListener('input', (e) => {
                params.seaLevel = parseFloat(e.target.value);
                document.getElementById('sealevel-value').textContent = params.seaLevel.toFixed(2);
                if (planet) planet.material.uniforms.uSeaLevel.value = params.seaLevel;
            });

            document.getElementById('rotation').addEventListener('input', (e) => {
                params.rotationSpeed = parseFloat(e.target.value);
                document.getElementById('rotation-value').textContent = params.rotationSpeed.toFixed(2);
            });

            document.getElementById('cloud-density').addEventListener('input', (e) => {
                params.cloudDensity = parseFloat(e.target.value);
                document.getElementById('cloud-density-value').textContent = params.cloudDensity.toFixed(2);
                if (clouds) clouds.material.uniforms.uCloudDensity.value = params.cloudDensity;
            });

            document.getElementById('bloom').addEventListener('input', (e) => {
                params.bloomIntensity = parseFloat(e.target.value);
                document.getElementById('bloom-value').textContent = params.bloomIntensity.toFixed(1);
                if (composer && composer.passes[1]) composer.passes[1].strength = params.bloomIntensity;
            });

            // Shading modes
            document.querySelectorAll('.btn-mode').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.btn-mode').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    params.shadingMode = btn.dataset.mode;
                    if (planet) {
                        const modes = { height: 0, temperature: 1, humidity: 2, volcano: 3 };
                        planet.material.uniforms.uShadingMode.value = modes[params.shadingMode];
                    }
                    updateLegend();
                });
            });

            // Toggles
            document.getElementById('daynight-toggle').addEventListener('click', (e) => {
                params.dayNightEnabled = !params.dayNightEnabled;
                e.target.classList.toggle('active', params.dayNightEnabled);
            });

            document.getElementById('atmosphere-toggle').addEventListener('click', (e) => {
                params.atmosphereEnabled = !params.atmosphereEnabled;
                e.target.classList.toggle('active', params.atmosphereEnabled);
                if (atmosphere) atmosphere.visible = params.atmosphereEnabled;
            });

            document.getElementById('rings-toggle').addEventListener('click', (e) => {
                params.ringsEnabled = !params.ringsEnabled;
                e.target.classList.toggle('active', params.ringsEnabled);
                if (rings) rings.visible = params.ringsEnabled;
            });

            // Presets
            document.getElementById('preset-earth').addEventListener('click', () => {
                params.roughness = 0.5; params.seaLevel = 0.4;
                document.getElementById('roughness').value = 0.5;
                document.getElementById('sealevel').value = 0.4;
                document.getElementById('roughness-value').textContent = '0.50';
                document.getElementById('sealevel-value').textContent = '0.40';
                if (planet) updateTerrain();
            });

            // UI buttons
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (!document.fullscreenElement) document.documentElement.requestFullscreen();
                else document.exitFullscreen();
            });

            document.getElementById('screenshot-btn').addEventListener('click', () => {
                document.getElementById('export-menu').style.display = 'block';
            });

            document.getElementById('export-screenshot').addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `planet-${Math.floor(currentSeed)}.png`;
                link.href = renderer.domElement.toDataURL();
                link.click();
                document.getElementById('export-menu').style.display = 'none';
            });

            document.getElementById('export-close').addEventListener('click', () => {
                document.getElementById('export-menu').style.display = 'none';
            });
        }

        function updateTerrain() {
            if (!planet || !originalPositions) return;
            const positions = planet.geometry.attributes.position.array;
            const elevations = planet.geometry.attributes.aElevation.array;

            for (let i = 0; i < positions.length; i += 3) {
                const ox = originalPositions[i], oy = originalPositions[i + 1], oz = originalPositions[i + 2];
                const len = Math.sqrt(ox * ox + oy * oy + oz * oz);
                const nx = ox / len, ny = oy / len, nz = oz / len;

                let elevation = 0;
                elevation += simplex.fbm(nx * 2, ny * 2, nz * 2, 6, 2, 0.5) * params.roughness;
                elevation += simplex.fbm(nx * 4.1, ny * 4, nz * 4, 4, 2, 0.5) * params.roughness * 0.3;
                let ridged = 1 - Math.abs(simplex.fbm(nx * 3, ny * 3, nz * 3, 4, 2, 0.5));
                ridged *= ridged;
                elevation += ridged * params.roughness * 0.4;
                elevation = Math.max(-0.5, Math.min(0.5, elevation));

                const newLen = 1 + elevation * 0.15;
                positions[i] = nx * newLen;
                positions[i + 1] = ny * newLen;
                positions[i + 2] = nz * newLen;
                elevations[i] = elevation;
            }

            planet.geometry.attributes.position.needsUpdate = true;
            planet.geometry.attributes.aElevation.needsUpdate = true;
            planet.geometry.computeVertexNormals();
        }

        function updateLegend() {
            const container = document.getElementById('legend-container');
            const gradient = document.getElementById('legend-gradient');
            const labels = document.getElementById('legend-labels');
            const title = container.querySelector('.legend-title');
            
            if (params.shadingMode === 'height') {
                title.textContent = 'Elevation';
                gradient.style.background = 'linear-gradient(90deg, #0a1933, #1a5788, #c4b280, #4a7c2d, #2d5a1a, #6a5952, #f0f0ff)';
                labels.innerHTML = '<span>Deep Ocean</span><span>Volcano Peaks</span>';
            } else if (params.shadingMode === 'temperature') {
                title.textContent = 'Temperature';
                gradient.style.background = 'linear-gradient(90deg, #e0f0ff, #4d80c0, #4db066, #e6d94d, #e64d33)';
                labels.innerHTML = '<span>Cold</span><span>Hot</span>';
            } else if (params.shadingMode === 'humidity') {
                title.textContent = 'Humidity';
                gradient.style.background = 'linear-gradient(90deg, #d9bf8c, #bf9e66, #668c4d, #3d6a33)';
                labels.innerHTML = '<span>Arid</span><span>Humid</span>';
            } else {
                title.textContent = 'Volcano Mode';
                gradient.style.background = 'linear-gradient(90deg, #ffffff, #ffaa00, #ff4400)';
                labels.innerHTML = '<span>Snow</span><span>Lava Glow</span>';
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        let lastTime = 0, fpsCounter = 0, fps = 0;
        function animate(time) {
            requestAnimationFrame(animate);
            params.time += 0.016;

            // Planet rotation
            if (planet) planet.rotation.y += params.rotationSpeed * 0.01;
            if (clouds) clouds.rotation.y += params.rotationSpeed * 0.015;
            if (rings && params.ringsEnabled) rings.rotation.z += 0.005;

            // Day-night cycle
            if (params.dayNightEnabled) {
                const sunAngle = params.time * 0.3;
                const sunPos = new THREE.Vector3(
                    Math.cos(sunAngle) * 5,
                    Math.sin(sunAngle) * 0.3 + 2,
                    Math.sin(sunAngle) * 5
                );
                sunLight.position.copy(sunPos);
                
                if (planet) planet.material.uniforms.uSunPosition.value.copy(sunPos);
                if (atmosphere) atmosphere.material.uniforms.uSunPosition.value.copy(sunPos);
            }

            // Update starfield
            if (starfield) {
                starfield.material.uniforms.uTime.value = params.time;
                starfield.rotation.y += 0.0001;
            }

            // Update shader times
            if (planet) planet.material.uniforms.uTime.value = params.time;
            if (clouds) clouds.material.uniforms.uTime.value = params.time;

            controls.update();
            
            // FPS counter
            fpsCounter++;
            if (time - lastTime >= 1000) {
                fps = Math.round((fpsCounter * 1000) / (time - lastTime));
                document.getElementById('fps-display').textContent = fps;
                fpsCounter = 0;
                lastTime = time;
            }

            composer.render();
        }

        // Start the application
        init();
    </script>
</body>
</html>
